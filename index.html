<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fishly-AI ‚Äî Dock POV Fishing (Mythicals + Log)</title>
<style>
  :root{
    --ink:#e8f1f2; --muted:#9fb3c8; --panel:#0b1f33; --accent:#2bb673; --danger:#ff6b6b; --gold:#f5c542;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:#061a2a;color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
  header{padding:10px 12px;text-align:center;background:#061a2a;border-bottom:1px solid #0c2c47}
  header h1{margin:0;font-size:18px}
  header small{color:var(--muted)}

  canvas{display:block; width:100vw; height:100vh; background:#06243a}

  /* HUD dock menu */
  .dockHUD{
    position:fixed; left:50%; transform:translateX(-50%);
    bottom:22px; z-index:6;
    background:linear-gradient(180deg, rgba(20,35,55,.9), rgba(10,22,40,.9));
    border:1px solid #0f3659; border-radius:12px; padding:10px 12px;
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    box-shadow:0 10px 30px rgba(0,0,0,.45);
  }
  .btn{background:var(--accent); border:none; border-radius:10px; padding:9px 12px; color:#06212f; font-weight:800; cursor:pointer}
  .btn:disabled{opacity:.6; cursor:not-allowed}
  .btn.alt{background:#1ea0c6; color:#073144}
  .btn.danger{background:var(--danger); color:#3a0b0b}
  .badge{padding:4px 8px; border-radius:999px; background:#0e3555; border:1px solid #154a73; color:#d1e6f7; font-size:.85rem}
  .money{color:var(--gold); font-weight:900}

  /* Meter */
  .meterWrap{
    position:fixed; left:50%; transform:translateX(-50%);
    bottom:100px; z-index:6; width:min(720px, 92vw);
    height:24px; border-radius:10px; overflow:hidden;
    background:#082132; border:1px solid #0e3a5d;
    box-shadow:0 8px 22px rgba(0,0,0,.3);
  }
  .meterFill{position:absolute; left:0; top:0; bottom:0; width:12%; background:linear-gradient(90deg,#1dd1a1,#10ac84)}
  .meterSweet{position:absolute; top:0; bottom:0; left:40%; width:10%;
    background:repeating-linear-gradient(90deg,rgba(255,255,255,.25) 0 4px,rgba(255,255,255,.15) 4px 8px)}
  .meterLabel{position:absolute; right:8px; top:2px; font-size:.8rem; color:#d4f3e6}

  .toast{position:fixed; left:50%; transform:translateX(-50%); bottom:160px; background:#0f2d4a; border:1px solid #134668; color:#e6f7ff;
    padding:8px 12px; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,.35); z-index:10; opacity:0; pointer-events:none; transition:opacity .25s ease, transform .25s ease;}
  .toast.show{opacity:1; transform:translate(-50%, -6px)}

  .netText{position:fixed; left:50%; transform:translateX(-50%); bottom:130px; color:#b3ecff; text-shadow:0 2px 10px rgba(0,0,0,.5); font-weight:800; opacity:0; transition:opacity .25s ease}

  /* Catch Log modal */
  dialog{border:0;border-radius:12px;padding:0;background:#0b1f33;color:#dff4ff;width:min(860px,94vw)}
  dialog::backdrop{background:rgba(0,0,0,.45)}
  .modal{padding:14px}
  .modal h2{margin:.2rem 0 .6rem}
  .grid{display:grid;gap:10px}
  .grid.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .card{background:#0e2a46;border:1px solid #134668;border-radius:10px;padding:10px}
  .stat{display:flex;justify-content:space-between;border-bottom:1px dashed #134668;padding:6px 0}
  .closeRow{display:flex;justify-content:flex-end;margin-top:8px}
  .btn.small{padding:6px 10px;font-weight:700}

  /* Mythical minigame overlay */
  .overlay{
    position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:20;
  }
  .overlay .panel{
    background:#0b1f33; border:1px solid #134668; border-radius:14px; padding:18px; width:min(520px,94vw); text-align:center;
    box-shadow:0 10px 30px rgba(0,0,0,.45)
  }
  .meterQuick{height:24px;border-radius:10px;background:#082132;border:1px solid #0e3a5d;overflow:hidden;margin:10px 0}
  .meterBar{height:100%;width:0;background:linear-gradient(90deg,#f5c542,#ff8a00)}

</style>
</head>
<body>
<header>
  <h1>Fishly-AI ‚Äî Dock POV Fishing</h1>
  <small>Cast the bobber ‚Ä¢ Reel on the green ‚Ä¢ Upgrade rod ‚Ä¢ Risk a net ‚Ä¢ Hunt mythicals</small>
</header>

<canvas id="game"></canvas>

<!-- Timing meter on dock -->
<div class="meterWrap" id="meter">
  <div class="meterSweet" id="sweet"></div>
  <div class="meterFill" id="fill"></div>
  <div class="meterLabel" id="meterLabel">Reel inside the sweet zone!</div>
</div>

<!-- Dock HUD -->
<div class="dockHUD">
  <span class="badge">Coins: <span id="coins">0</span> üí∞</span>
  <span class="badge">Rod Lv <span id="rodLv">1</span></span>
  <button class="btn" id="castBtn">üé£ Cast</button>
  <button class="btn" id="reelBtn" disabled>üåÄ Reel</button>
  <button class="btn alt" id="rodBtn">Upgrade Rod (<span class="money" id="rodCost">50</span>)</button>
  <button class="btn danger" id="netBtn">Throw Net (200)</button>
  <button class="btn" id="logBtn">üìò Catch Log</button>
  <button class="btn alt" id="soundBtn">üîä Sound</button>
</div>

<div class="toast" id="toast" role="status" aria-live="polite"></div>
<div class="netText" id="netText">THROWING NET‚Ä¶</div>

<!-- Catch Log -->
<dialog id="dlgLog"><div class="modal">
  <h2>Catch Log & Stats</h2>
  <div class="grid cols-2">
    <div class="card">
      <h3>Totals</h3>
      <div class="stat"><span>Coins earned</span><strong id="logCoins">0</strong></div>
      <div class="stat"><span>Rod Level</span><strong id="logRod">1</strong></div>
      <div class="stat"><span>Fish caught (normal)</span><strong id="logFish">0</strong></div>
      <div class="stat"><span>Mythicals caught</span><strong id="logMyth">0</strong></div>
      <div class="stat"><span>Nets thrown</span><strong id="logNets">0</strong></div>
    </div>
    <div class="card" id="logSpecies"><h3>By Species</h3><div id="speciesList"></div></div>
  </div>
  <div class="closeRow"><button class="btn small" onclick="dlgLog.close()">Close</button></div>
</div></dialog>

<!-- Mythical Minigame -->
<div class="overlay" id="mythOverlay">
  <div class="panel">
    <h2>üî• You hooked a Mythical! Click fast to reel it in!</h2>
    <div>Time: <span id="mythTime">6.0</span>s ‚Äî Power: <span id="mythPower">0%</span></div>
    <div class="meterQuick"><div class="meterBar" id="mythBar"></div></div>
    <div><button class="btn" id="mythClick">REEL! üñ±Ô∏è</button> <button class="btn danger" id="mythSkip">Let it go üò≠</button></div>
  </div>
</div>

<script>
/* =========================
   CANVAS & SCENE BASICS
========================= */
const c = document.getElementById('game');
const ctx = c.getContext('2d');
function resize(){ c.width = innerWidth; c.height = innerHeight; }
addEventListener('resize', resize); resize();

/* =========================
   LIGHT AUDIO (WebAudio)
========================= */
let AC = null, soundOn = true;
function ensureAC(){ if(!AC){ AC = new (window.AudioContext||window.webkitAudioContext)(); } }
function beep(freq=440, ms=120, gain=0.05){
  if(!soundOn) return;
  ensureAC();
  const o = AC.createOscillator(), g = AC.createGain();
  o.type='sine'; o.frequency.value=freq;
  g.gain.value=gain;
  o.connect(g); g.connect(AC.destination);
  o.start(); o.stop(AC.currentTime + ms/1000);
}
function splashSfx(){ beep(220,120,0.04); setTimeout(()=>beep(320,90,0.03),70); }
function coinSfx(){ beep(660,80,0.05); setTimeout(()=>beep(990,80,0.04),60); }
function errorSfx(){ beep(160,200,0.06); }

/* =========================
   STATE & SAVE
========================= */
const state = {
  coins: 0, coinsAllTime: 0,
  rodLv: 1,
  casting: false,
  meterT: Math.random(), meterDir: Math.random()<.5?-1:1,
  sweetStart: 0.46, sweetWidth: 0.08,
  bobber: null,
  wavesTick: 0,
  sprites: [], ripples: [], lines: [],
  netAnim: null, netsThrown: 0,
  // day/night + weather
  time: 0, // seconds; loop 0..120
  weather: 'calm', // calm, breezy, overcast
  // log
  fishCount: 0,
  bySpecies: {},
  mythCount: 0,
  // mythical event
  mythicalActive: false,
  lastHit: {x:0,y:0}
};

const SAVE_KEY='fishly_pov_save_v4';
function save(){ try{ localStorage.setItem(SAVE_KEY, JSON.stringify({coins:state.coins, coinsAllTime:state.coinsAllTime, rodLv:state.rodLv, bySpecies:state.bySpecies, fishCount:state.fishCount, mythCount:state.mythCount, netsThrown:state.netsThrown})); }catch{} }
function load(){
  try{
    const raw = localStorage.getItem(SAVE_KEY); if(!raw) return;
    const s = JSON.parse(raw);
    Object.assign(state, {coins:s.coins||0, coinsAllTime:s.coinsAllTime||0, rodLv:s.rodLv||1, bySpecies:s.bySpecies||{}, fishCount:s.fishCount||0, mythCount:s.mythCount||0, netsThrown:s.netsThrown||0});
  }catch{}
}
load();

/* =========================
   ECONOMY & FISH TABLES
========================= */
const FISH = [
  {n:"Bluegill", r:"common",  v:[3,6],  color:"#63a46c"},
  {n:"Crappie",  r:"common",  v:[3,7],  color:"#cfd3d6"},
  {n:"Perch",    r:"common",  v:[4,8],  color:"#f2c84b"},
  {n:"Largemouth Bass", r:"uncommon", v:[10,20], color:"#5aa870"},
  {n:"Smallmouth Bass", r:"uncommon", v:[10,22], color:"#9a7b50"},
  {n:"Walleye",  r:"uncommon", v:[12,24], color:"#9bb17a"},
  {n:"Channel Catfish", r:"uncommon", v:[10,26], color:"#9aa3ad"},
  {n:"Northern Pike", r:"rare", v:[20,40], color:"#3d6f4d"},
  {n:"Muskellunge", r:"epic", v:[40,80], color:"#4d7f63"},
  {n:"Common Carp", r:"uncommon", v:[8,22], color:"#caa23a"}
];
const RARITY_WEIGHT = { common:1.0, uncommon:0.45, rare:0.15, epic:0.05 };

function weatherBonus(){
  // overcast slightly boosts predators; breezy boosts walleye/bass; calm is neutral.
  if(state.weather==='overcast') return {uncommon:+0.08, rare:+0.02};
  if(state.weather==='breezy')   return {uncommon:+0.06, rare:+0.03};
  return {uncommon:+0.0, rare:+0.0};
}

function chooseFish(){
  const bonus = 0.02*(state.rodLv-1);
  const wb = weatherBonus();
  const w = FISH.map(f=>{
    let base = RARITY_WEIGHT[f.r] || 0.3;
    if(f.r==='uncommon') base += bonus*0.6 + (wb.uncommon||0);
    if(f.r==='rare')     base += bonus*0.35 + (wb.rare||0);
    if(f.r==='epic')     base += bonus*0.2; // small always-on bonus
    return Math.max(0.01, base);
  });
  let sum=w.reduce((a,b)=>a+b,0), pick=Math.random()*sum;
  for(let i=0;i<FISH.length;i++){ if(pick<w[i]) return FISH[i]; pick-=w[i]; }
  return FISH[0];
}
function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

/* =========================
   MYTHICALS
========================= */
const MYTHICALS = [
  {n:'Unicorn Fish',  min:120, max:300, sprite:'unicorn', color:'#ff6bd6'},
  {n:'Kitty Fish',    min:80,  max:180, sprite:'kitty',   color:'#ffcc66'},
  {n:'Cyber Koi',     min:100, max:220, sprite:'cyber',   color:'#66e0ff'},
  {n:'Ghost Bass',    min:150, max:350, sprite:'ghost',   color:'#c2e9ff'},
  {n:'Scuba Diver',   min:50,  max:120, sprite:'diver',   color:'#a0b4ff'}, /* funny one */
  {n:'Rainbow Pike',  min:200, max:500, sprite:'rainbow', color:'#7df3b6'}  /* top tier */
];
function pickMyth(){ return MYTHICALS[Math.floor(Math.random()*MYTHICALS.length)]; }

/* =========================
   UI ELEMENTS
========================= */
const UI = {
  coins: document.getElementById('coins'),
  rodLv: document.getElementById('rodLv'),
  castBtn: document.getElementById('castBtn'),
  reelBtn: document.getElementById('reelBtn'),
  rodBtn: document.getElementById('rodBtn'),
  rodCost: document.getElementById('rodCost'),
  netBtn: document.getElementById('netBtn'),
  logBtn: document.getElementById('logBtn'),
  soundBtn: document.getElementById('soundBtn'),
  meter: document.getElementById('meter'),
  sweet: document.getElementById('sweet'),
  fill: document.getElementById('fill'),
  meterLabel: document.getElementById('meterLabel'),
  toast: document.getElementById('toast'),
  netText: document.getElementById('netText'),
  // log modal
  dlgLog: document.getElementById('dlgLog'),
  logCoins: document.getElementById('logCoins'),
  logRod: document.getElementById('logRod'),
  logFish: document.getElementById('logFish'),
  logMyth: document.getElementById('logMyth'),
  logNets: document.getElementById('logNets'),
  speciesList: document.getElementById('speciesList'),
  mythOverlay: document.getElementById('mythOverlay'),
  mythClick: document.getElementById('mythClick'),
  mythSkip: document.getElementById('mythSkip'),
  mythTime: document.getElementById('mythTime'),
  mythPower: document.getElementById('mythPower'),
  mythBar: document.getElementById('mythBar')
};

/* =========================
   SWEET SPOT (Lv1‚ÜíLv100)
========================= */
function updateSweetByRodLevel(){
  const L = clamp(state.rodLv,1,100);
  const width = 0.08 + (1.00 - 0.08) * ((L-1)/99); // 8% ‚Üí 100%
  state.sweetWidth = clamp(width, 0.08, 1.0);
  state.sweetStart = 0.5 - state.sweetWidth/2;
  UI.sweet.style.left = (state.sweetStart*100)+'%';
  UI.sweet.style.width = (state.sweetWidth*100)+'%';
}
updateSweetByRodLevel();

/* =========================
   CONTROLS
========================= */
UI.castBtn.addEventListener('click', ()=>{
  if(state.casting) return;
  startCast();
});
UI.reelBtn.addEventListener('click', ()=> reelAttempt());
UI.rodBtn.addEventListener('click', ()=>{
  const cost = rodCost();
  if(state.coins < cost){ toast('Not enough coins.'); errorSfx(); return; }
  if(state.rodLv >= 100){ toast('Rod maxed at Lv100'); return; }
  state.coins -= cost; state.coinsAllTime += 0; state.rodLv++;
  updateSweetByRodLevel();
  toast(`Rod upgraded to Lv ${state.rodLv}!`);
  coinSfx();
  renderUI(); save();
});
UI.netBtn.addEventListener('click', ()=> throwNet());
UI.logBtn.addEventListener('click', ()=> openLog());
UI.soundBtn.addEventListener('click', ()=>{
  soundOn = !soundOn;
  UI.soundBtn.textContent = soundOn ? 'üîä Sound' : 'üîà Muted';
  if(soundOn) beep(880,80,0.04);
});

/* =========================
   METER
========================= */
function updateMeter(dt){
  state.meterT += state.meterDir * (0.6 + 0.02*(state.rodLv-1)) * dt;
  if(state.meterT<=0){ state.meterT=0; state.meterDir=1; }
  if(state.meterT>=1){ state.meterT=1; state.meterDir=-1; }
  UI.fill.style.width = (state.meterT*100)+'%';
}

/* =========================
   CAST / REEL LOGIC
========================= */
function startCast(){
  state.casting = true;
  UI.reelBtn.disabled = false;

  // Chance for mythical minigame trigger upfront (5%)
  if(Math.random() < 0.05){
    // still cast bobber for visuals
    castBobber();
    setTimeout(()=> startMythicalGame(), 500);
    return;
  }
  castBobber();
}

function reelAttempt(){
  if(!state.casting) return;
  const t = state.meterT;
  const s0 = state.sweetStart, s1 = state.sweetStart + state.sweetWidth;
  const hit = (t>=s0 && t<=s1);
  finishCast(hit);
}

function finishCast(success){
  if(state.bobber){ state.bobber.landed=false; state.bobber.fly=0; }
  state.bobber = null;
  state.casting = false;
  UI.reelBtn.disabled = true;

  if(success){
    const f = chooseFish();
    const val = Math.round(rand(f.v[0], f.v[1]));
    state.coins += val; state.coinsAllTime += val; coinSfx();
    // log
    state.fishCount++;
    state.bySpecies[f.n] = (state.bySpecies[f.n]||0)+1;

    spawnFishSprite(state.lastHit.x, state.lastHit.y, f.color);
    splash(state.lastHit.x, state.lastHit.y);
    toast(`+1 ${f.n}  (+$${val})`);
  } else {
    toast('Missed it! Try again.');
    errorSfx();
  }
  renderUI(); save();
}

/* =========================
   BOBBER & CAST ANIM
========================= */
function castBobber(){
  // randomize sweet position on each cast
  const jitter = (Math.random()*0.2 - 0.1);
  state.sweetStart = clamp(0.5 - state.sweetWidth/2 + jitter, 0, 1 - state.sweetWidth);
  UI.sweet.style.left = (state.sweetStart*100)+'%';

  // choose random target water point
  const waterTop = Math.floor(c.height*0.42);
  const waterBottom = Math.floor(c.height*0.88);
  const tx = rand(c.width*0.18, c.width*0.82);
  const ty = rand(waterTop+20, waterBottom-20);

  // start near dock front middle
  const sx = c.width*0.5;
  const sy = c.height*0.86;

  state.bobber = {x:sx, y:sy, fly:0, landed:false, tx, ty, cx:(sx+tx)/2 + rand(-80,80), cy:Math.min(sy, ty)-rand(100,160)};
}

function animateBobber(dt){
  const b = state.bobber;
  if(!b) return;

  if(!b.landed){
    b.fly = clamp(b.fly + dt*1.4, 0, 1);
    const t = b.fly;
    const x = (1-t)*(1-t)*b.x + 2*(1-t)*t*b.cx + t*t*b.tx;
    const y = (1-t)*(1-t)*b.y + 2*(1-t)*t*b.cy + t*t*b.ty;
    // cast trail
    state.lines.push({x0:b.x, y0:b.y, x1:x, y1:y, life:0.18});
    b.x = x; b.y = y;

    if(t>=1){
      b.landed = true;
      state.lastHit.x = b.x; state.lastHit.y = b.y;
      splash(b.x,b.y); splashSfx();
    }
  } else {
    // gentle bobbing
    const t = performance.now()/1000;
    b.y += Math.sin(t*2.6)*0.15;
  }
}

/* =========================
   NET GAMBLE
========================= */
function throwNet(){
  if(state.casting) { toast('Finish your cast first.'); return; }
  if(state.coins < 200){ toast('Need 200 coins for a net.'); errorSfx(); return; }
  state.coins -= 200; state.netsThrown++; renderUI(); save();

  // choose target
  const waterTop = Math.floor(c.height*0.42);
  const waterBottom = Math.floor(c.height*0.88);
  const x = rand(c.width*0.22, c.width*0.78);
  const y = rand(waterTop+30, waterBottom-30);

  // animate net ring
  UI.netText.style.opacity = 1;
  setTimeout(()=> UI.netText.style.opacity=0, 700);
  state.netAnim = {x, y, t:0};
  splash(x,y); splashSfx();

  setTimeout(()=>{
    const roll = Math.random();
    let n = 0;
    if(roll < 0.18) n = Math.floor(rand(0,2.99));      // loss
    else if(roll < 0.78) n = Math.floor(rand(3,8.99)); // average
    else n = Math.floor(rand(9,20.99));                // big haul

    let total = 0;
    for(let i=0;i<n;i++){
      const f = chooseFish();
      const val = Math.round(rand(f.v[0], f.v[1]));
      total += val; state.fishCount++; state.bySpecies[f.n]=(state.bySpecies[f.n]||0)+1;
      spawnFishSprite(x + rand(-50,50), y + rand(-30,20), f.color);
    }
    state.coins += total; state.coinsAllTime += total;
    if(n===0) { toast('The net came up empty‚Ä¶ üò¨'); errorSfx(); }
    else if(total < 200) toast(`Net haul: ${n} fish, only $${total}‚Ä¶ (loss)`);
    else if(total < 350) { toast(`Net haul: ${n} fish, $${total} ‚Äî not bad!`); coinSfx(); }
    else { toast(`JACKPOT! Net haul: ${n} fish for $${total}!`); coinSfx(); coinSfx(); }
    save();
  }, 850);
}

/* =========================
   SPRITES / SPLASH / DRAW
========================= */
function spawnFishSprite(x,y,color){
  state.sprites.push({x, y, vx: rand(-20,20), vy: -rand(60,100), life:0, maxLife:1.1, color});
}
function splash(x,y){
  for(let i=0;i<3;i++){ state.ripples.push({x, y, r:6+i*3, vr: 70+Math.random()*50, alpha:0.8}); }
}

/* Mythical sprites (canvas-drawn) */
function drawMythSprite(kind, x, y, a=1){
  ctx.save(); ctx.translate(x,y); ctx.globalAlpha = a; ctx.lineWidth=2; ctx.strokeStyle='#172b39';
  switch(kind){
    case 'unicorn': // rainbow body + horn
      const grd = ctx.createLinearGradient(-22,0,22,0);
      ['#ff6bd6','#ff9a62','#fff94d','#85f78b','#6fd3ff','#a48bff'].forEach((c,i)=>grd.addColorStop(i/5,c));
      ctx.fillStyle = grd;
      ctx.beginPath(); ctx.ellipse(0,0,22,12,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(8,-6); ctx.lineTo(18,-18); ctx.lineTo(12,-6); ctx.closePath(); ctx.fillStyle='#fff'; ctx.fill(); ctx.stroke();
      break;
    case 'kitty': // fish with cat ears
      ctx.fillStyle = '#ffcc66';
      ctx.beginPath(); ctx.ellipse(0,0,22,12,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-6,-10); ctx.lineTo(-2,-18); ctx.lineTo(2,-10); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(6,-10); ctx.lineTo(2,-18); ctx.lineTo(-2,-10); ctx.closePath(); ctx.fill(); ctx.stroke();
      break;
    case 'cyber': // neon circuits
      ctx.fillStyle='#66e0ff';
      ctx.beginPath(); ctx.ellipse(0,0,22,12,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.strokeStyle='#0ff'; ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(-10,-2); ctx.lineTo(0,-2); ctx.lineTo(8,-8); ctx.stroke();
      ctx.beginPath(); ctx.arc(6,0,3,0,Math.PI*2); ctx.stroke();
      break;
    case 'ghost': // translucent
      ctx.globalAlpha = a*0.65;
      ctx.fillStyle='#c2e9ff';
      ctx.beginPath(); ctx.ellipse(0,0,22,12,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.globalAlpha = a;
      break;
    case 'diver': // tiny diver with bubbles
      ctx.fillStyle='#2a3c6b';
      ctx.fillRect(-6,-8,12,16);
      ctx.fillStyle='#1e2a50'; ctx.fillRect(-10,4,20,6);
      ctx.fillStyle='#7fb3ff'; ctx.beginPath(); ctx.arc(0,-10,6,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillStyle='rgba(255,255,255,.8)';
      [0,1,2].forEach(i=>{ ctx.beginPath(); ctx.arc(10+i*6,-20-i*8,3-i*0.5,0,Math.PI*2); ctx.fill(); });
      break;
    case 'rainbow': // rainbow pikey thing
      const g2 = ctx.createLinearGradient(-26,0,26,0);
      ['#ff3b3b','#ffa238','#fffb45','#5eff7a','#3bd3ff','#a56bff'].forEach((c,i)=>g2.addColorStop(i/5,c));
      ctx.fillStyle = g2;
      ctx.beginPath(); ctx.ellipse(0,0,26,10,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      break;
  }
  // tail
  ctx.beginPath(); ctx.moveTo(-24,0); ctx.lineTo(-36,-8); ctx.lineTo(-36,8); ctx.closePath(); ctx.fill(); ctx.stroke();
  ctx.restore();
}

/* =========================
   DRAW SCENE (day/night + weather)
========================= */
function drawScene(dt){
  // time & weather
  state.time += dt; if(state.time>120) state.time=0; // 2 min loop full day
  // simple phases: 0-30 dawn, 30-60 day, 60-90 dusk, 90-120 night
  const t = state.time, phase = (t<30)?'dawn':(t<60)?'day':(t<90)?'dusk':'night';
  if(Math.random()<0.001){ state.weather = ['calm','breezy','overcast'][Math.floor(Math.random()*3)]; }

  // Sky gradient per phase
  const skyH = Math.floor(c.height*0.42);
  const sky = ctx.createLinearGradient(0,0,0,skyH);
  if(phase==='day'){ sky.addColorStop(0,'#175d9b'); sky.addColorStop(1,'#0f3f6e'); }
  else if(phase==='dawn'){ sky.addColorStop(0,'#f09b4f'); sky.addColorStop(1,'#0f3f6e'); }
  else if(phase==='dusk'){ sky.addColorStop(0,'#a0479e'); sky.addColorStop(1,'#0d2f55'); }
  else { sky.addColorStop(0,'#081426'); sky.addColorStop(1,'#071a2d'); }
  ctx.fillStyle = sky; ctx.fillRect(0,0,c.width,skyH);

  // Water gradient
  const waterTop = skyH;
  const waterBottom = Math.floor(c.height*0.9);
  const water = ctx.createLinearGradient(0,waterTop,0,waterBottom);
  if(phase==='night'){ water.addColorStop(0, '#0f3260'); water.addColorStop(1, '#0a2742'); }
  else { water.addColorStop(0, '#1e90ff'); water.addColorStop(0.45, '#237ec7'); water.addColorStop(1, '#145a86'); }
  ctx.fillStyle = water; ctx.fillRect(0,waterTop,c.width,waterBottom-waterTop);

  // Waves
  state.wavesTick += dt * (state.weather==='breezy' ? 1.5 : 1.0);
  ctx.save();
  ctx.globalAlpha = phase==='night' ? 0.12 : 0.18;
  ctx.strokeStyle = 'rgba(255,255,255,0.35)';
  for(let i=0;i<8;i++){
    const y = waterTop + (i+1)*(waterBottom-waterTop)/10 + Math.sin(state.wavesTick*0.9 + i)*6;
    ctx.beginPath();
    for(let x=0;x<c.width;x+=14){
      const yy = y + Math.sin((x*0.02) + i + state.wavesTick*1.2)*2.2;
      if(x===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
    }
    ctx.stroke();
  }
  ctx.restore();

  // Dock
  const dockTop = waterBottom;
  ctx.fillStyle = '#6b4a34';
  ctx.fillRect(0,dockTop,c.width,c.height-dockTop);
  ctx.strokeStyle = '#5c3f2b'; ctx.lineWidth = 2;
  for(let x=0;x<c.width;x+=80){ ctx.beginPath(); ctx.moveTo(x,dockTop); ctx.lineTo(x,c.height); ctx.stroke(); }
  ctx.globalAlpha = .25; ctx.strokeStyle = '#7b583f';
  for(let i=0;i<10;i++){
    const yy = dockTop + 14 + i*10;
    ctx.beginPath(); ctx.moveTo(0,yy);
    for(let x=0;x<c.width;x+=18){ const off = Math.sin((x+i*21)*0.03 + i)*1.2; ctx.lineTo(x, yy+off); }
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Cast trail segments
  for(let i=state.lines.length-1;i>=0;i--){
    const seg = state.lines[i];
    seg.life -= dt;
    if(seg.life<=0){ state.lines.splice(i,1); continue; }
    ctx.strokeStyle = `rgba(255,255,255,${0.6*seg.life/0.18})`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(seg.x0,seg.y0); ctx.lineTo(seg.x1,seg.y1); ctx.stroke();
  }

  // Ripples
  for(let i=state.ripples.length-1;i>=0;i--){
    const rp = state.ripples[i];
    rp.r += rp.vr*dt;
    rp.alpha -= dt*0.8;
    if(rp.alpha<=0){ state.ripples.splice(i,1); continue; }
    ctx.strokeStyle = `rgba(255,255,255,${rp.alpha})`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(rp.x,rp.y,rp.r,0,Math.PI*2); ctx.stroke();
  }

  // Bobber
  if(state.bobber){
    ctx.beginPath();
    ctx.arc(state.bobber.x, state.bobber.y, 9, 0, Math.PI*2);
    ctx.fillStyle = '#ff4757'; ctx.fill();
    ctx.lineWidth = 3; ctx.strokeStyle = '#ffffff'; ctx.stroke();
  }

  // Net anim
  if(state.netAnim){
    state.netAnim.t = Math.min(1, (state.netAnim.t + dt*1.6));
    const t2 = state.netAnim.t, r = 20 + 120*t2;
    ctx.save();
    ctx.globalAlpha = 0.25*(1-t2)+0.1;
    ctx.strokeStyle = '#b3ecff'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(state.netAnim.x, state.netAnim.y, r, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(state.netAnim.x-r, state.netAnim.y); ctx.lineTo(state.netAnim.x+r, state.netAnim.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(state.netAnim.x, state.netAnim.y-r); ctx.lineTo(state.netAnim.x, state.netAnim.y+r); ctx.stroke();
    ctx.restore();
    if(t2>=1) state.netAnim = null;
  }

  // Normal fish sprites
  for(let i=state.sprites.length-1;i>=0;i--){
    const sp = state.sprites[i];
    sp.life += dt; sp.x += sp.vx*dt; sp.y += sp.vy*dt; sp.vy += 50*dt;
    const a = 1 - (sp.life/sp.maxLife);
    if(a<=0){ state.sprites.splice(i,1); continue; }
    ctx.save(); ctx.translate(sp.x, sp.y); ctx.rotate(Math.sin(sp.life*6)*0.15); ctx.globalAlpha = clamp(a,0,1);
    ctx.fillStyle = sp.color; ctx.strokeStyle = '#172b39'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.ellipse(0,0,20,10,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-20,0); ctx.lineTo(-32,-8); ctx.lineTo(-32,8); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.restore();
  }

  // If mythical active, draw a faint silhouette jumping near bobber spot for drama (optional)
}

/* =========================
   LOOP
========================= */
let last = performance.now();
function tick(now){
  const dt = Math.min(0.033, (now-last)/1000); last = now;

  updateMeter(dt);
  animateBobber(dt);
  drawScene(dt);

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* =========================
   HELPERS / UI
========================= */
function toast(msg){
  UI.toast.textContent = msg;
  UI.toast.classList.add('show');
  setTimeout(()=>UI.toast.classList.remove('show'), 1500);
}
function rodCost(){ return 50 + Math.floor((state.rodLv-1)*20); }
function renderUI(){
  UI.coins.textContent = state.coins;
  UI.rodLv.textContent = state.rodLv;
  UI.rodCost.textContent = rodCost();
}

/* =========================
   LOG MODAL
========================= */
const dlgLog = document.getElementById('dlgLog');
function openLog(){
  UI.logCoins.textContent = state.coinsAllTime;
  UI.logRod.textContent = state.rodLv;
  UI.logFish.textContent = state.fishCount;
  UI.logMyth.textContent = state.mythCount;
  UI.logNets.textContent = state.netsThrown;
  const rows = Object.entries(state.bySpecies).sort((a,b)=>b[1]-a[1]).map(([k,v])=>`<div class="stat"><span>${k}</span><strong>${v}</strong></div>`).join('') || '<em>No catches yet‚Ä¶</em>';
  UI.speciesList.innerHTML = rows;
  dlgLog.showModal();
}

/* =========================
   MYTHICAL MINIGAME
========================= */
let mythTimer = null, mythTimeLeft = 6.0, mythPower = 0, mythTarget = 100, mythPrize = null;
function startMythicalGame(){
  if(state.mythicalActive) return;
  state.mythicalActive = true;
  mythPrize = pickMyth();
  mythTimeLeft = 6.0;
  mythPower = 0; mythTarget = 100; // click to reach 100%
  UI.mythBar.style.width = '0%';
  UI.mythTime.textContent = mythTimeLeft.toFixed(1);
  UI.mythPower.textContent = '0%';
  UI.mythOverlay.style.display = 'flex';
  beep(880,120,0.05);

  const tick = ()=>{
    mythTimeLeft -= 0.1;
    if(mythTimeLeft<=0){
      endMyth(false);
    }else{
      UI.mythTime.textContent = mythTimeLeft.toFixed(1);
      mythTimer = setTimeout(tick,100);
    }
  };
  mythTimer = setTimeout(tick,100);
}
function endMyth(success){
  clearTimeout(mythTimer); mythTimer=null;
  UI.mythOverlay.style.display = 'none';
  state.mythicalActive = false;

  if(success){
    const award = Math.round(rand(mythPrize.min, mythPrize.max));
    state.coins += award; state.coinsAllTime += award; state.mythCount++;
    spawnMythicalBurst(state.lastHit.x, state.lastHit.y, mythPrize.sprite);
    toast(`${mythPrize.n} landed! +$${award}`);
    coinSfx(); coinSfx();
    save(); renderUI();
  }else{
    toast('The mythical slipped away‚Ä¶');
    errorSfx();
  }
}
UI.mythClick.addEventListener('click', ()=>{
  if(!state.mythicalActive) return;
  mythPower += 6 + Math.random()*4; // mash!
  if(mythPower>100) mythPower=100;
  UI.mythPower.textContent = Math.round(mythPower)+'%';
  UI.mythBar.style.width = Math.round(mythPower)+'%';
  beep(660,40,0.03);
  if(mythPower>=mythTarget){ endMyth(true); }
});
UI.mythSkip.addEventListener('click', ()=> endMyth(false));

function spawnMythicalBurst(x,y,kind){
  // spawn 3 mythical sprites rising
  for(let i=0;i<3;i++){
    mythicalSprites.push({x:x+rand(-20,20), y:y+rand(-8,8), vx:rand(-10,10), vy:-rand(70,110), life:0, maxLife:1.4, kind});
  }
}
const mythicalSprites = [];
// piggyback draw: append at end of drawScene
const origDrawScene = drawScene;
drawScene = function(dt){
  origDrawScene(dt);
  // draw mythical sprites
  for(let i=mythicalSprites.length-1;i>=0;i--){
    const sp = mythicalSprites[i];
    sp.life += dt; sp.x += sp.vx*dt; sp.y += sp.vy*dt; sp.vy += 40*dt;
    const a = 1 - (sp.life/sp.maxLife);
    if(a<=0){ mythicalSprites.splice(i,1); continue; }
    drawMythSprite(sp.kind, sp.x, sp.y, clamp(a,0,1));
  }
}

/* =========================
   START
========================= */
renderUI();
toast('Welcome! Cast your line and reel on the green. (5% chance: Mythical minigame!)');
</script>
</body>
</html>
